<html lang="en" data-theme=""><head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gold Writer</title> 
<script src="src/jspdf.umd.min.js"></script>

<style>
:root {
--silver-gradient: linear-gradient(to right, #42424f, #42424f);
--white-gradient: linear-gradient(to right, #fff, #fff);
--active-link-color: #fff;
--background-color: #151519;
--link-hover-color: #616274;
--link-color: #42424f;
--text-color: #fff;
}

[data-theme='light'] {
--black-gradient: linear-gradient(to right, #000, #000);
--active-link-color: #444;
--background-color: #fff;
--link-hover-color: #666;
--text-color: #111;
--link-color: #bbb;
}

/* Gold Gradient */
.gold-gradient .sentence::before, 
.gold-gradient hr {
background: linear-gradient(to right, #BF953F, #FCF6BA, #dcb06c, #AA771C);
}

.gold-gradient .section-nav::before {
background: linear-gradient(to bottom, #BF953F, #FCF6BA, #dcb06c, #AA771C);
}

.gold-gradient .section-nav li.active > a {
color: var(--active-link-color);
background: linear-gradient(to right, #BF953F, #FCF6BA, #dbc789, #FBF5B7, #AA771C); 
-webkit-text-fill-color: transparent;
-webkit-background-clip: text;
}

.gold-gradient input[type="text"] {
background: linear-gradient(to right, #BF953F, #FCF6BA, #dbc789, #FBF5B7, #AA771C); 
-webkit-text-fill-color: transparent;
-webkit-background-clip: text;
}

html {
scroll-behavior: auto; /* smooth */
overflow-x: hidden; 
}

body {
margin: 0;
background: var(--background-color);
color: var(--text-color);
font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
}

main > nav {
align-self: start;
position: sticky;
top: 22px;
}

.section-nav {
position: relative;
padding-left: 10px; 
margin: 1rem 0;
border: none;
}

.section-nav a {
text-decoration: none;
white-space: nowrap; 
margin-left: 16px;
overflow: hidden; 
padding: .5rem 0;
display: block;
outline: none;
color: var(--link-color);
transition: all 50ms ease-in-out;
}

.section-nav a:hover,
.section-nav a:focus {
color: var(--link-hover-color);
}

.section-nav::before {
content: "";
position: absolute;
top: 0;
left: 0;
bottom: 0;
width: 1.5px; 
border-radius: 10px;
background: var(--silver-gradient);
}

.section-nav li.active > a {
color: var(--active-link-color);
background: var(--white-gradient);
-webkit-text-fill-color: transparent;
-webkit-background-clip: text;
background-clip: text;
font-size: inherit;
font-weight: bold;
outline: none;
border: none;
}

hr {
background: var(--silver-gradient);
border-radius: 10px;
margin: 1rem 0; 
height: 1.5px; 
border: none;
}

[data-theme='light'] hr {
background-image: var(--black-gradient);
}

[data-theme='light'] .section-nav::before {
background: var(--black-gradient); 
}

[data-theme='light'] .section-nav li.active > a {
color: var(--active-link-color);
background: var(--black-gradient); 
-webkit-text-fill-color: transparent;
-webkit-background-clip: text;
}

[data-theme='light'] input[type="text"] {
color: var(--active-link-color);
background: var(--black-gradient); 
-webkit-text-fill-color: transparent;
-webkit-background-clip: text;
}

[data-theme='light'] .sentence::before {
background-image: var(--black-gradient);
padding: 2px; 
}

[data-theme='light'] .sentence {
color: black;
}

* {
box-sizing: border-box;
}

ul, ol {
list-style: none;
margin: 10px 0px;
padding: 0;
}

main {
grid-template-columns: 20em 1fr;
margin-left: 40px;
display: grid;
width: 90%;
gap: 1rem;
word-wrap: break-word; 
overflow-wrap: break-word; 
}

.section {
padding-top: 20px;
}

section {
padding-bottom: 10rem;
}

.content {
border: none;
outline: none;
margin-top: 20px;
min-height: 350px;
word-wrap: break-word; 
overflow-wrap: break-word; 
white-space: pre-wrap;
line-height: 1.8;
font-size: 15px;
max-width: 100%;
}

.theme-toggle {
background: linear-gradient(to right, white 50%, black 50%);
border: white solid 1px;
border-radius: 50%;
position: fixed;
cursor: pointer;
height: 18px;
width: 18px;
right: 43px;
top: 43px;
}

[data-theme='light'] .theme-toggle {
border-color: black; 
}

.theme-toggle:hover {
opacity: 0.8;
}

input[type="text"] {
background-color: var(--background-color);
color: var(--text-color);
font-size: 1.5rem;
font-weight: bold;
background: none;
outline: none;
border: none;
padding: 0px;
width: 100%;
box-sizing: border-box; 
}

.highlight-yellow {
background: linear-gradient(to right, #BF953F, #FCF6BA, #dbc789, #FBF5B7, #AA771C);
border: 1.5px solid #cdb27a; 
border-radius: 3px;
position: relative; 
font-weight: bold;
padding: 1px 4px;
color: black;
z-index: -1;
}

.sentence {
font-family: Arial, sans-serif;
border-radius: 10px;
position: relative;
text-align: left;
padding: 1em 2em;
margin: 1em 0;
max-width: 100%;
width: auto;
color: #e0e0e0;
outline: none;
cursor: text;
z-index: 1;
box-sizing: border-box;
border: 1px solid #42424f;
background: var(--background-color);
word-wrap: break-word;
overflow-wrap: break-word;
white-space: normal;
word-break: break-word;
}

.sentence::before {
  content: "";
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  border-radius: 10px;
  padding: 1px;
  /* your gold gradient: */
  background: linear-gradient(to right, #BF953F, #FCF6BA, #dcb06c, #AA771C);
  /* eat away the middle: */
  -webkit-mask: 
    linear-gradient(#fff 0 0) content-box, 
    linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask: 
    linear-gradient(#fff 0 0) content-box, 
    linear-gradient(#fff 0 0);
  mask-composite: exclude;
  z-index: -1;
}

/*
.sentence::before {
content: "";
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
border-radius: 10px;
padding: 1px; 
background: var(--white-gradient);
mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
-webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
mask-composite: exclude;
z-index: -1;
}
*/


@media (max-width: 800px) {
nav {
display: none; 
}

main {
grid-template-columns: 1fr;
padding-right: 40px;
margin-left: 40px;
display: grid;
gap: 1rem;
}
}



main {
word-wrap: break-word;
overflow-wrap: break-word;
max-width: 100%;
margin: 0 auto; /* Center the content */
}

</style>
</head>
<body class="gold-gradient">
<button class="theme-toggle"></button>
<main>
<nav><ul class="section-nav" id="navList"><li class="active"><a href="#part1" class="nav-link">the END of Everything BAD</a></li><li class=""><a href="#part2" class="nav-link">the END of Everything BAD</a></li><li class=""><a href="#part3" class="nav-link">the END of Everything BAD</a></li><li class=""><a href="#part4" class="nav-link">the END of Everything BAD</a></li><li class=""><a href="#part5" class="nav-link">the END of Everything BAD</a></li><li class=""><a href="#part6" class="nav-link">the END of Everything BAD</a></li><li class=""><a href="#part7" class="nav-link">the END of Everything BAD</a></li><li class=""><a href="#part8" class="nav-link">the END of Everything BAD</a></li></ul></nav>
<div>
<div class="sections">
<section class="section" id="part1">
<h2><input type="text" value="the END of Everything BAD" readonly="true"></h2>
<div class="content"><div><span style="color: var(--text-color); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif;"><br></span></div><div><span style="color: var(--text-color); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif;">the END of Everything BAD</span><br></div><div><br></div><div><div class="sentence">( the END of Everything BAD ) =<br><br>( BADNESS-ELLIMINATION-GOALS ) =<br>GOAL 1 = "the END of BADNESS"<br>GOAL 2 = "the END of INVOLUNTARY LIFE SITUATIONS"<br>GOAL 3 = "the END of DYSTOPIA"<br>GOAL 4 = "the END of VIOLENCE" →<br>GOAL 5 = "the END of MINDHARM" → <br>GOAL 6 = "the END of EVILNESS" → <br>GOAL 7 = "the END of CONFLICT"<br>GOAL 8 = "the END of EXTINCTION"<br>GOAL 9 = "the END of SUFFERING"<br>GOAL 10 = "the END of DEATH"<br></div><div class="sentence">GOODest COSMIC GOALs to MAXIMALLY ACHIEVE? =&nbsp;<br></div><div class="sentence">PROTECT EVERYONE from<br>(DYSTOPIA), (EXTINCTION) , (VIOLENCE), (MINDHARM), (EVIL) , (INVOLUNTARYNESS), (SUFFERING),(DEATH), (DYSTROPY), (DANGER), (CONFLICT).</div><br></div><div><br></div><div><br></div></div>
</section>
<section class="section" id="part2">
<h2><input type="text" value="the END of Everything BAD" readonly="true"></h2>
<div class="content">the END of Everything BAD</div>
</section>
<section class="section" id="part3">
<h2><input type="text" value="the END of Everything BAD" readonly="true"></h2>
<div class="content">the END of Everything BAD</div>
</section>
<section class="section" id="part4">
<h2><input type="text" value="the END of Everything BAD" readonly="true"></h2>
<div class="content">the END of Everything BAD</div>
</section>
<section class="section" id="part5">
<h2><input type="text" value="the END of Everything BAD" readonly="true"></h2>
<div class="content">the END of Everything BAD</div>
</section>
<section class="section" id="part6">
<h2><input type="text" value="the END of Everything BAD" readonly="true"></h2>
<div class="content">the END of Everything BAD</div>
</section>
<section class="section" id="part7">
<h2><input type="text" value="the END of Everything BAD" readonly="true"></h2>
<div class="content">the END of Everything BAD</div>
</section>
<section class="section" id="part8">
<h2><input type="text" value="the END of Everything BAD" readonly="true"></h2>
<div class="content">the END of Everything BAD</div>
</section>
</div>
</div>
</main>

<script>
document.addEventListener('keydown', (event) => {
const selection = window.getSelection();
const range = selection.rangeCount ? selection.getRangeAt(0) : null;
const parent = range ? range.startContainer.parentNode : null;

if ((event.metaKey || event.ctrlKey) && (event.key.toLowerCase() === 'k')) {
event.preventDefault();
insertQuote();
}

if (event.key === 'Backspace' && parent) {
handleBackspace(event, parent, range);
}

if (event.key === 'Escape' && parent && parent.classList.contains('sentence')) {
event.preventDefault();
const newLine = document.createElement('p');
newLine.setAttribute('contenteditable', 'true');
newLine.innerHTML = '&nbsp;';
parent.parentNode.insertBefore(newLine, parent.nextSibling);
const newRange = document.createRange();
newRange.setStart(newLine, 0);
newRange.collapse(true);
selection.removeAllRanges();
selection.addRange(newRange);
}});

function insertQuote() {
const selection = window.getSelection();
if (!selection.rangeCount) return;
const selectedRange = selection.getRangeAt(0);
const parentQuote = findAncestor(selectedRange.startContainer, 'sentence');
if (parentQuote) return;
const range = selection.getRangeAt(0);
const newElement = document.createElement('div');
newElement.className = 'sentence';
newElement.setAttribute('contenteditable', 'true');
newElement.innerHTML = `&nbsp;`;
range.insertNode(newElement);
selection.removeAllRanges();
newElement.focus();
const newLine = document.createElement('p');
newLine.setAttribute('contenteditable', 'true');
newLine.innerHTML = '&nbsp;';
newElement.parentNode.insertBefore(newLine, newElement.nextSibling);
const newRange = document.createRange();
newRange.setStart(newElement, 0);
newRange.collapse(true);
selection.removeAllRanges();
selection.addRange(newRange);
}

function findAncestor(element, className) {
while (element) {
if (element.classList && element.classList.contains(className)) {
return element;
}
element = element.parentElement;
}
return null;
}

function focusAndSelect(element) {
element.focus();
const newRange = document.createRange();
newRange.selectNodeContents(element);
newRange.collapse(false);
const selection = window.getSelection();
selection.removeAllRanges();
selection.addRange(newRange);
}
</script>


<script>
let highlightCounter = 0;

function highlightSelection() {
const selection = window.getSelection();
if (!selection.rangeCount) return; 
const range = selection.getRangeAt(0);
const selectedText = range.toString().trim(); 
if (!selectedText) return; 

// Create new highlight
highlightCounter++;
const highlightId = `highlight-${highlightCounter}`;
const span = document.createElement('span');
span.className = 'highlight-yellow';
span.id = highlightId;

// Check if existing highlight
const existingHighlight = findAncestor(range.startContainer, 'highlight-yellow');
if (existingHighlight) {
// Remove existing highlight
const parent = existingHighlight.parentNode;
while (existingHighlight.firstChild) {
parent.insertBefore(existingHighlight.firstChild, existingHighlight);
}
parent.removeChild(existingHighlight);
console.log('Highlight removed:', highlightId);
return; // Exit after removal
}

// Insert the highlight
range.surroundContents(span);

// Add a space after the highlight if needed
const startOffset = range.startOffset;
const endOffset = range.endOffset;
const startText = range.startContainer.textContent;
const endText = range.endContainer.textContent;

const hasLetterAfter = endOffset < endText.length && /\S/.test(endText[endOffset]);
if (hasLetterAfter) {
span.insertAdjacentHTML('afterend', '&nbsp;');
}

// Clear the selection
selection.removeAllRanges();

// Place the caret after the highlight and the added space
const newRange = document.createRange();
newRange.setStartAfter(span.nextSibling || span);
newRange.collapse(true);
selection.addRange(newRange);

console.log(`Highlight added: ${span.id}`); 
}


// Find the closest ancestor with a specific class
function findAncestor(element, className) {
while (element) {
if (element.classList && element.classList.contains(className)) {
return element;
}
element = element.parentElement;
}
return null;
}

// Prevent splitting highlight on Enter key
function preventSplitOnEnter(event) {
const selection = window.getSelection();
if (selection.rangeCount) {
const range = selection.getRangeAt(0);
const startContainer = range.startContainer;
if (findAncestor(startContainer, 'highlight-yellow')) {
event.preventDefault(); 
console.log('Prevented splitting highlight on Enter key');
}}
}

// Function to handle arrow key to add spaces
function handleArrowKeys(event) {
const selection = window.getSelection();
if (selection.rangeCount) {
const range = selection.getRangeAt(0);
const startContainer = range.startContainer;
const endContainer = range.endContainer;

// If cursor is at the start of a highlight
if (event.key === 'ArrowLeft' && range.startOffset === 0) {
const highlight = findAncestor(startContainer, 'highlight-yellow');
if (highlight && !/\S/.test(startContainer.textContent.slice(0, range.startOffset))) {
highlight.insertAdjacentHTML('beforebegin', '&nbsp;'); // Add space before highlight
console.log('Added space before highlight');
}
}

// If cursor is at the end of a highlight
if (event.key === 'ArrowRight' && range.endOffset === endContainer.textContent.length) {
const highlight = findAncestor(endContainer, 'highlight-yellow');
if (highlight) {
// Check the next sibling
const nextSibling = highlight.nextSibling;

// Check if the next sibling is a text node and contains only whitespace
const isNextSiblingWhitespace = nextSibling && nextSibling.nodeType === Node.TEXT_NODE && !/\S/.test(nextSibling.textContent);

// Check if next sibling is an entity for non-breaking space
const isNextSiblingNbsp = nextSibling && nextSibling.nodeType === Node.TEXT_NODE && nextSibling.textContent === '\u00A0'; // Non-breaking space in Unicode

// Only add space if no space exists after highlight
if (!isNextSiblingWhitespace && !isNextSiblingNbsp) {
highlight.insertAdjacentHTML('afterend', '&nbsp;'); // Add space after highlight
console.log('Added space after highlight');
} else {
console.log('Not adding space after highlight as it already exists');
}}}}
}

// Event listener to trigger highlighting
document.addEventListener('keydown', (event) => {
if ((event.metaKey || event.ctrlKey) && (event.key === 'h' || event.key === 'H')) {
event.preventDefault(); 
highlightSelection(); 
} else if (event.key === 'Enter') {
preventSplitOnEnter(event); // Prevent split 
} else if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
handleArrowKeys(event); 
}});

</script>

<script> 
// Function to handle paste events across multiple contenteditable sections
function handlePaste(event) {
    event.preventDefault();
    
    // Get the clipboard data (both plain text and HTML)
    const clipboardData = (event.clipboardData || window.clipboardData).getData('text/html');
    const plainTextData = (event.clipboardData || window.clipboardData).getData('text/plain');
    
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    
    const range = selection.getRangeAt(0);
    
    // If clipboard contains HTML (rich text with formatting like bold)
    if (clipboardData) {
        const fragment = document.createDocumentFragment();
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = clipboardData;
        
        // Insert HTML content into the current selection
        Array.from(tempDiv.childNodes).forEach(node => fragment.appendChild(node));
        
        range.deleteContents();
        range.insertNode(fragment);
        range.collapse(false);
    } else {
        // If clipboard only contains plain text, convert it to HTML format with <br> for new lines
        const sanitizedText = plainTextData.replace(/\r?\n|\r/g, '<br>');
        
        const fragment = document.createDocumentFragment();
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = sanitizedText;
        
        // Insert plain text as HTML with <br> for new lines
        Array.from(tempDiv.childNodes).forEach(node => fragment.appendChild(node));
        
        range.deleteContents();
        range.insertNode(fragment);
        range.collapse(false);
    }
}

// Attach the paste handler to all contenteditable sections
const contentEditableElements = document.querySelectorAll('[contenteditable="true"]');
contentEditableElements.forEach(element => {
    element.addEventListener('paste', handlePaste);
});

</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
const sections = document.querySelectorAll('section');
const navList = document.getElementById('navList');
const navLinks = [];

function updateNavLinks() {
navList.innerHTML = '';
navLinks.length = 0; // Clear existing links

sections.forEach((section) => {
const headerInput = section.querySelector('h2 input');
const listItem = document.createElement('li');
const anchor = document.createElement('a');

anchor.href = `#${section.id}`;
anchor.className = 'nav-link';
anchor.textContent = headerInput.value; // Set initial text from input

listItem.appendChild(anchor);
navList.appendChild(listItem);
navLinks.push(anchor);

// Update link text when input changes
headerInput.addEventListener('input', () => {
anchor.textContent = headerInput.value;
});
});
}

updateNavLinks();

// Set first nav link as active on load
if (navLinks.length > 0) {
navLinks[0].parentNode.classList.add('active');
}
navLinks.forEach((link, index) => {
link.addEventListener('click', (e) => {
e.preventDefault();
const targetSection = document.querySelector(link.getAttribute('href'));
// Update URL in the address bar without reloading page
history.pushState(null, '', link.getAttribute('href'));
targetSection.scrollIntoView({
behavior: 'smooth',
block: 'start'
});
setActiveLink(index);
});
});

window.addEventListener('scroll', () => {
let scrollPos = window.scrollY || document.documentElement.scrollTop;
sections.forEach((section, index) => {
if (scrollPos >= section.offsetTop - section.clientHeight / 2 &&
scrollPos < section.offsetTop + section.clientHeight / 2) {
setActiveLink(index); // Set active link on scroll
}});
});

// Function to set active link
function setActiveLink(index) {
navLinks.forEach(link => link.parentNode.classList.remove('active'));
if (navLinks[index]) {
navLinks[index].parentNode.classList.add('active');
}
}

// Function to scroll to section based on URL hash
function scrollToHash(hash) {
const targetSection = document.querySelector(hash);
if (targetSection) {
targetSection.scrollIntoView({
behavior: 'smooth',
block: 'start'
});
}
}

// Get hash in URL on load
if (window.location.hash) {
scrollToHash(window.location.hash);
}

// Listen for hash changes in the URL
window.addEventListener('hashchange', () => {
scrollToHash(window.location.hash);
});


// Save HTML file on Cmd + E
document.addEventListener('keydown', (event) => {
if ((event.ctrlKey || event.metaKey) && (event.key === 'e' || event.key === 'E')) {
event.preventDefault();
saveHTML();
}});

// Copy to clipboard on ctrl + X
function copySectionsToClipboard() {
const textToCopy = Array.from(sections).map(section => {
const header = section.querySelector('h2 input').value; 
const content = section.querySelector('.content').innerText; 
return `${header}\n${content}\n`; 
}).join('\n\n');
navigator.clipboard.writeText(textToCopy).then(() => {
console.log('Copied to clipboard successfully!');
}, (err) => {
console.error('Could not copy text: ', err);
});
}// Copy all headers and content on Ctrl + X
document.addEventListener('keydown', (event) => {
if ((event.ctrlKey || event.metaKey) && (event.key === 'x' || event.key === 'X')) {
event.preventDefault();
copySectionsToClipboard();
}});


// Save HTML file
function saveHTML() {
// Clone the document to avoid altering the live document
const clone = document.documentElement.cloneNode(true);

// Get all input elements in the cloned 
const headerInputs = clone.querySelectorAll('h2 input');
document.querySelectorAll('h2 input').forEach((input, index) => {
if (headerInputs[index]) {
headerInputs[index].setAttribute('value', input.value); // Set input value to current text
headerInputs[index].removeAttribute('contenteditable'); // Remove any editable attributes if present
headerInputs[index].setAttribute('readonly', 'true'); // Set to readonly 
}});
// Remove contenteditable from all elements
const editableElements = clone.querySelectorAll('[contenteditable]');
editableElements.forEach(el => el.removeAttribute('contenteditable')); 
// Create a Blob and initiate download
const blob = new Blob([clone.outerHTML], { type: 'text/html' });
const link = document.createElement('a');
link.href = URL.createObjectURL(blob);
link.download = 'document.html';
link.click();
URL.revokeObjectURL(link.href);
}


// Theme toggle functionality 
const themeToggleButton = document.querySelector('.theme-toggle');
const currentTheme = localStorage.getItem('theme') || ''; // Set default to light theme
document.documentElement.setAttribute('data-theme', currentTheme); // Use light theme by default

themeToggleButton.addEventListener('click', () => {
const currentTheme = document.documentElement.getAttribute('data-theme');
const newTheme = currentTheme === 'light' ? '' : 'light'; // Toggle between light and light
document.documentElement.setAttribute('data-theme', newTheme);
localStorage.setItem('theme', newTheme);
});
// Check and apply the gold gradient class on page load
const goldGradientActive = localStorage.getItem('gold-gradient') === 'true';
if (goldGradientActive) {
document.body.classList.add('gold-gradient');
}

// Toggle gold gradient class with keyboard shortcut
document.addEventListener('keydown', function(event) {
if ((event.key === 'g' || event.key === 'G') && (event.metaKey || event.ctrlKey)) {
event.preventDefault(); // Prevent any default behavior
document.body.classList.toggle('gold-gradient');
// Update localStorage to remember the state
const isActive = document.body.classList.contains('gold-gradient');
localStorage.setItem('gold-gradient', isActive);
}});


// Check if Cmd key is pressed without Shift
document.addEventListener('keydown', (event) => {
if (event.metaKey && !event.shiftKey) { 
const keyNumber = parseInt(event.key);
if (keyNumber >= 1 && keyNumber <= sections.length) { // Ensure it matches available sections
event.preventDefault();
const targetSection = document.getElementById(`part${keyNumber}`); // Adjusted ID reference
if (targetSection) {
targetSection.scrollIntoView({
behavior: 'smooth',
block: 'start'
});
setActiveLink(keyNumber - 1); 
}}}
});


document.addEventListener('keydown', (event) => {
if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'u') {
event.preventDefault();
insertDivider();
}});

function insertDivider() {
const activeElement = document.activeElement;
if (activeElement && activeElement.isContentEditable) {
const hr = document.createElement('hr');
const selection = window.getSelection();
if (selection.rangeCount > 0) {
const range = selection.getRangeAt(0);
range.collapse(false); 
range.insertNode(hr);
range.setStartAfter(hr);
range.setEndAfter(hr);
selection.removeAllRanges();
selection.addRange(range);
const p = document.createElement('p');
p.innerHTML = "<br>"; // Empty line placeholder 
range.insertNode(p); // InsertNode empty line
range.setStart(p, 0);// Set cursor inside
range.setEnd(p, 0);
}
} else {
console.warn('Cursor is not in a contenteditable area');
}
}

// Save project data as a js file on CMD + S
document.addEventListener('keydown', (event) => {
if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 's') {
event.preventDefault();
saveAsJSFile();
}});

// Load project data from js file on CMD + O
document.addEventListener('keydown', (event) => {
if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'o') {
event.preventDefault();
loadFromJSFile();
}});

// Function to save data as a .js file
function saveAsJSFile() {
const sectionsData = Array.from(sections).map(section => {
const header = section.querySelector('h2 input').value;
const content = section.querySelector('.content').innerHTML;
return { header, content };
});

const blob = new Blob([`const projectData = ${JSON.stringify(sectionsData, null, 2)};`], { type: 'application/javascript' });
const link = document.createElement('a');
link.href = URL.createObjectURL(blob);
link.download = 'projectData.js';
link.click();
URL.revokeObjectURL(link.href);
}

// Function to load data from a .js file
function loadFromJSFile() {
const input = document.createElement('input');
input.type = 'file';
input.accept = '.js';
input.onchange = (event) => {
const file = event.target.files[0];
if (file) {
const reader = new FileReader();
reader.onload = (e) => {
try {
const data = e.target.result;
const projectData = eval(data.replace('const projectData =', '').trim()); // Use eval to get the object
restoreData(projectData);
updateNavLinks(); // Update navigation links after restoring data
} catch (error) {
console.error('Error loading project data:', error);
}};
reader.readAsText(file);
}};
input.click();
}

// Function to restore data into the page
function restoreData(projectData) {
projectData.forEach((sectionData, index) => {
const section = sections[index];
if (section) {
section.querySelector('h2 input').value = sectionData.header;
section.querySelector('.content').innerHTML = sectionData.content;
}});
}

// Update navigation links 
function updateNavLinks() {
navList.innerHTML = ''; 
navLinks.length = 0; // Clear
sections.forEach((section) => {
const headerInput = section.querySelector('h2 input'); // Get the input element
const listItem = document.createElement('li');
const anchor = document.createElement('a');
anchor.href = `#${section.id}`;
anchor.className = 'nav-link';
anchor.textContent = headerInput.value; 
// Set initial text from the input
listItem.appendChild(anchor);
navList.appendChild(listItem);
navLinks.push(anchor);
// Update link text when input changes
headerInput.addEventListener('input', () => {
anchor.textContent = headerInput.value;
});
});
}


// Enable drag-and-drop to load data from a .js file
document.body.addEventListener('dragover', (event) => {
event.preventDefault();
event.dataTransfer.dropEffect = 'copy'; // Show copy effect on drag
});

document.body.addEventListener('drop', (event) => {
event.preventDefault();
const file = event.dataTransfer.files[0];
if (file && file.name.endsWith('.js')) {
const reader = new FileReader();
reader.onload = (e) => {
try {
const data = e.target.result;
const projectData = eval(data.replace('const projectData =', '').trim()); // Use eval to get the object
restoreData(projectData);
updateNavLinks(); // Update navigation links after restoring data
} catch (error) {
console.error('Error loading project data:', error);
}};
reader.readAsText(file);
} else {
console.error('Please drop a valid .js file');
}});


// Create a range and select all text 
document.addEventListener('keydown', (event) => {
if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'a') {
const activeElement = document.activeElement;
// Check if the active element is an input 
if (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable) {
// Allow default selection behavior
return; 
} else {
event.preventDefault(); 
const selection = window.getSelection();
selection.removeAllRanges();
const range = document.createRange(); 
const contentDiv = document.querySelector('main > div');
contentDiv.childNodes.forEach(node => {
if (node.nodeType === Node.ELEMENT_NODE) {
if (!node.closest('nav')) { 
range.selectNodeContents(node);
selection.addRange(range); 
}}});
}}});



});

</script>
<script>
function moveSelectionToTopOfCurrentSection() {
const selection = window.getSelection();
if (!selection.rangeCount) return;

const range = selection.getRangeAt(0);
if (range.collapsed) return;

const extractedContent = range.cloneContents();
range.deleteContents();

// Find the closest .section ancestor
const section = findAncestor(range.startContainer, 'section');
if (!section) return;

const contentArea = section.querySelector('.content');
if (!contentArea) return;

// Wrap the moved content
const wrapper = document.createElement('span');
wrapper.appendChild(extractedContent);

// Create a line break after it
const lineBreak = document.createElement('p');
lineBreak.innerHTML = '<br>'; // Empty paragraph for spacing

// Insert both at the top
const firstChild = contentArea.firstChild;
if (firstChild) {
contentArea.insertBefore(lineBreak, firstChild);
contentArea.insertBefore(wrapper, lineBreak);
} else {
contentArea.appendChild(wrapper);
contentArea.appendChild(lineBreak);
}

// Move cursor after the line break
const newRange = document.createRange();
newRange.setStart(lineBreak, 0);
newRange.collapse(true);
selection.removeAllRanges();
selection.addRange(newRange);
}
// CMD+@ to move text selection top top of section 
document.addEventListener('keydown', (event) => {
if ((event.metaKey || event.ctrlKey) && event.key === '@') {
event.preventDefault();
moveSelectionToTopOfCurrentSection();
}
});
</script>
<script>
function moveSelectionToBottomOfCurrentSection() {
  const selection = window.getSelection();
  if (!selection.rangeCount) return;

  const range = selection.getRangeAt(0);
  if (range.collapsed) return;

  const extractedContent = range.cloneContents();
  range.deleteContents();

  // Find the closest .section ancestor
  const section = findAncestor(range.startContainer, 'section');
  if (!section) return;

  const contentArea = section.querySelector('.content');
  if (!contentArea) return;

  // Wrap the moved content
  const wrapper = document.createElement('span');
  wrapper.appendChild(extractedContent);

  // Create a line break after it
  const lineBreak = document.createElement('p');
  lineBreak.innerHTML = '<br>'; // Empty paragraph for spacing

  // Insert both at the bottom
  const lastChild = contentArea.lastChild;
  if (lastChild) {
    contentArea.appendChild(wrapper);
    contentArea.appendChild(lineBreak);
  } else {
    contentArea.appendChild(wrapper);
    contentArea.appendChild(lineBreak);
  }

  // Move cursor after the line break
  const newRange = document.createRange();
  newRange.setStartAfter(lineBreak);
  newRange.collapse(true);
  selection.removeAllRanges();
  selection.addRange(newRange);
}

// CMD+Æ to move text selection to bottom of section
document.addEventListener('keydown', (event) => {
  if ((event.metaKey || event.ctrlKey) && (event.key === 'Æ' || event.key === 'æ')) {
    event.preventDefault();
    moveSelectionToBottomOfCurrentSection();
  }
});


// EXPORT PDF
 document.addEventListener('keydown', (event) => {
  if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'p') {
    event.preventDefault();
    exportToPDF();
  }
});

function exportToPDF() {
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'pt',
    format: 'a4'
  });

  // Configuration
  const margin = 40;
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const maxWidth = pageWidth - 2 * margin;
  let currentY = margin;

  // Font settings
  doc.setFont('Helvetica');
  doc.setFontSize(16); // Header size
  const lineHeight = 16 * 1.2;
  const contentFontSize = 12;
  const contentLineHeight = contentFontSize * 1.2;

  // Get all sections
  const sections = document.querySelectorAll('.section');

  sections.forEach((section, index) => {
    // Get header and content
    const header = section.querySelector('h2 input').value;
    const content = section.querySelector('.content').innerText;

    // Add header
    doc.setFontSize(16);
    doc.setFont('Helvetica', 'bold');
    const headerLines = doc.splitTextToSize(header, maxWidth);
    if (currentY + headerLines.length * lineHeight > pageHeight - margin) {
      doc.addPage();
      currentY = margin;
    }
    doc.text(headerLines, margin, currentY);
    currentY += headerLines.length * lineHeight + 10;

    // Add content
    doc.setFontSize(contentFontSize);
    doc.setFont('Helvetica', 'normal');
    const contentLines = doc.splitTextToSize(content, maxWidth);
    contentLines.forEach(line => {
      if (currentY + contentLineHeight > pageHeight - margin) {
        doc.addPage();
        currentY = margin;
      }
      doc.text(line, margin, currentY);
      currentY += contentLineHeight;
    });

    // Add spacing between sections
    currentY += 20;
    if (index < sections.length - 1 && currentY > pageHeight - margin - 20) {
      doc.addPage();
      currentY = margin;
    }
  });

  // Save the PDF
  doc.save('document.pdf');
}



// EXPORT TXT
document.addEventListener('keydown', (event) => {
  if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'i') {
    event.preventDefault();
    exportToText();
  }
});

function exportToText() {
  const sections = document.querySelectorAll('.section');
  const textContent = Array.from(sections).map(section => {
    const header = section.querySelector('h2 input').value;
    const content = section.querySelector('.content').innerText;
    return `${header}\n${content}\n`;
  }).join('\n');

  const blob = new Blob([textContent], { type: 'text/plain' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'document.txt';
  link.click();
  URL.revokeObjectURL(link.href);
}





// EXPORT SIMPLE HTML
document.addEventListener('keydown', (event) => {
  if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'd') {
    event.preventDefault();
    exportToHTML();
  }
});

function exportToHTML() {
  const sections = document.querySelectorAll('.section');
  let htmlContent = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Exported Document</title>
  <style>
    body {
      background-color: #000000;
      color: #ffffff;
      font-family: Arial, sans-serif;
      margin: 40px;
      line-height: 1.6;
    }
    h2 {
      font-size: 1.5em;
      margin-bottom: 0.5em;
    }
    .content {
      margin-bottom: 2em;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
`;

  sections.forEach(section => {
    const header = section.querySelector('h2 input').value;
    const content = section.querySelector('.content').innerText;
    htmlContent += `
  <h2>${header}</h2>
  <div class="content">${content}</div>
`;
  });

  htmlContent += `
</body>
</html>
`;

  const blob = new Blob([htmlContent], { type: 'text/html' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'exported_document.html';
  link.click();
  URL.revokeObjectURL(link.href);
}
</script>

</body></html>
